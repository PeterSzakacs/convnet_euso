# -*- coding: utf-8 -*-

from __future__ import division, print_function, absolute_import

import sys
import os
import importlib
import tflearn
import tensorflow as tf
import numpy as np
import utils.cmd_interface_convnet as cmd
import utils.ConvLayerVisualizer as convViz
import utils.FullyConnectedLayerVisualizer as fcViz

cmd_int = cmd.cmd_interface()
args = cmd_int.get_cmd_args(sys.argv[1:])
#print(args)

width, height = args.width, args.height
network_module_names = args.networks
num_epochs = args.epochs
basedir = args.srcdir
if basedir == None:
    basedir = os.path.join(os.path.dirname(__file__), "../res/")
outputdir = "../out/"

Xfile = basedir + args.infile + ".npy"
Yfile = basedir + args.targetfile + ".npy"

X = np.load(Xfile).reshape([-1, width, height, 1]).astype(np.uint32)
Y = np.load(Yfile).reshape([-1, 2])

# uncomment callbacks-related code if you want to see visually in generated images at each output what the outputs 
# of the convolutional (well, technically, max-pooling, and only first 10 filters) and FC layers are after each epoch
#
# NOTE: however, the network to be trained next, if there is one and it also has the relevant callback lines of code 
# uncommented, will overwrite the images generated by the previous network (TODO: might want to implement specifying 
# an output directory when creating these callbacks to avoid this side-effect)

for module_name in network_module_names:
    network_module = importlib.import_module("net." + module_name)
    graph = tf.Graph()
    with graph.as_default():
        network, conv_layers, fc_layers = network_module.create(inputShape=[None, width, height, 1])
        model = tflearn.DNN(network, tensorboard_verbose=0, tensorboard_dir=outputdir+module_name)
#        convCallback = convViz.VisualizerCallback(model, X[0:100], conv_layers)
#        fcCallback = fcViz.VisualizerCallback(model, X[0:100], fc_layers)
        model.fit({'input': X}, {'target': Y}, n_epoch=num_epochs, validation_set=0.1,
                  snapshot_step=100, show_metric=True, run_id=module_name)#, callbacks=[convCallback, fcCallback])
        if args.save == True:
            model.save("{}.tflearn".format(module_name))
